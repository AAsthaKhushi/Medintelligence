# MedGenie 2.0 - Complete AI Workflow Guide

## Overview
This guide explains the complete AI pipeline in MedGenie 2.0, from prescription upload to intelligent chat interactions. The system uses OpenAI's GPT-4o for multimodal processing and text-embedding-3-small for semantic search capabilities.

## AI Architecture Flow

```
üìÑ File Upload ‚Üí üîç AI Extraction ‚Üí üìä Data Processing ‚Üí üß† Vector Embedding ‚Üí üí¨ Intelligent Chat
     ‚Üì              ‚Üì                 ‚Üì                    ‚Üì                    ‚Üì
  User uploads    GPT-4o Vision    Structured JSON     Text Embeddings    Context-Aware
  prescription    extracts data    stored in DB       for similarity      chat responses
```

---

## Phase 1: Multimodal Prescription Extraction

### 1.1 File Processing Pipeline

**Supported Formats:**
- **PDF Files**: Medical prescriptions, lab reports
- **Images**: JPG, PNG of handwritten/printed prescriptions  
- **DOCX**: Digital prescription documents

**Processing Steps:**
1. **File Upload** ‚Üí Supabase Storage
2. **File Retrieval** ‚Üí Edge Function downloads file
3. **Format Conversion** ‚Üí Convert to base64 for OpenAI API
4. **AI Processing** ‚Üí GPT-4o Vision analyzes content

### 1.2 GPT-4o Vision Extraction

**System Prompt for Extraction:**
```
You are MedGenie AI, specialized in extracting structured medical data from prescription documents. 

TASK: Extract prescription information and return ONLY valid JSON format.

REQUIRED JSON STRUCTURE:
{
  "doctorName": "Full doctor name with credentials",
  "hospitalClinic": "Medical facility name", 
  "consultationDate": "YYYY-MM-DD format",
  "patientName": "Patient full name",
  "diagnosis": "Primary medical condition/symptoms",
  "medicines": [
    {
      "name": "Complete medicine name",
      "genericName": "Generic/salt name if mentioned", 
      "dosage": "Strength (e.g., 500mg, 10ml)",
      "frequency": "How often (e.g., twice daily, every 8 hours)",
      "duration": "Treatment period (e.g., 7 days, 2 weeks)",
      "instructions": "Special instructions (before/after food, etc.)",
      "quantity": "Total quantity prescribed"
    }
  ],
  "vitalSigns": {
    "bloodPressure": "if mentioned",
    "temperature": "if mentioned", 
    "weight": "if mentioned",
    "pulse": "if mentioned"
  },
  "followUpDate": "Next appointment date if mentioned",
  "specialInstructions": "General care instructions",
  "prescriptionNumber": "Prescription ID if visible"
}

EXTRACTION RULES:
1. Extract ALL visible text accurately
2. If handwritten, interpret carefully
3. For unclear text, use "Not clearly visible" 
4. Maintain medical terminology precision
5. Include dosage units (mg, ml, tablets)
6. Convert frequency to standardized format
7. Extract both brand and generic names when available
8. Note any drug interactions mentioned
9. Include dietary restrictions if specified
10. Preserve doctor's special notes

QUALITY CHECKS:
- Verify medicine names against common pharmaceuticals
- Ensure dosage values are medically reasonable  
- Cross-reference frequency with standard prescribing
- Validate date formats
- Check for completeness of critical fields
```

**Vision Processing:**
```typescript
const extractionPrompt = {
  model: "gpt-4o",
  messages: [
    {
      role: "system", 
      content: EXTRACTION_SYSTEM_PROMPT
    },
    {
      role: "user",
      content: [
        {
          type: "text",
          text: "Extract prescription data from this medical document. Return only valid JSON."
        },
        {
          type: "image_url",
          image_url: {
            url: `data:image/jpeg;base64,${base64File}`,
            detail: "high" // High resolution for medical text
          }
        }
      ]
    }
  ],
  max_tokens: 2000,
  temperature: 0.1 // Low temperature for accuracy
}
```

### 1.3 Data Validation & Error Handling

**Post-Extraction Validation:**
```typescript
interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  confidence: number;
}

const validateExtractedData = (data: any): ValidationResult => {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  // Critical field validation
  if (!data.doctorName || data.doctorName.length < 3) {
    errors.push("Doctor name missing or invalid");
  }
  
  if (!data.medicines || data.medicines.length === 0) {
    errors.push("No medicines extracted");
  }
  
  // Medicine validation
  data.medicines?.forEach((med: any, index: number) => {
    if (!med.name) errors.push(`Medicine ${index + 1}: Name missing`);
    if (!med.dosage) warnings.push(`Medicine ${index + 1}: Dosage unclear`);
    if (!med.frequency) warnings.push(`Medicine ${index + 1}: Frequency missing`);
  });
  
  // Date validation
  if (data.consultationDate && !isValidDate(data.consultationDate)) {
    warnings.push("Consultation date format unclear");
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    confidence: calculateConfidence(data, errors, warnings)
  };
};
```

---

## Phase 2: Semantic Embedding Generation

### 2.1 Text Preparation for Embedding

**Context Building:**
```typescript
const buildEmbeddingText = (prescriptionData: ExtractedData): string => {
  const components = [
    // Doctor and facility info
    `Doctor: ${prescriptionData.doctorName}`,
    prescriptionData.hospitalClinic && `Hospital: ${prescriptionData.hospitalClinic}`,
    
    // Medical context
    `Diagnosis: ${prescriptionData.diagnosis}`,
    prescriptionData.specialInstructions && `Instructions: ${prescriptionData.specialInstructions}`,
    
    // Medicines with detailed context
    ...prescriptionData.medicines.map(med => 
      `Medicine: ${med.name} ${med.genericName ? `(${med.genericName})` : ''} - ${med.dosage} - ${med.frequency} for ${med.duration} - ${med.instructions}`
    ),
    
    // Additional medical data
    prescriptionData.vitalSigns && Object.entries(prescriptionData.vitalSigns)
      .filter(([_, value]) => value)
      .map(([key, value]) => `${key}: ${value}`)
      .join(', '),
      
    // Temporal context
    `Date: ${prescriptionData.consultationDate}`
  ].filter(Boolean);
  
  return components.join(' | ');
};
```

### 2.2 OpenAI Embedding Generation

**Embedding Configuration:**
```typescript
const generateEmbedding = async (text: string): Promise<number[]> => {
  const response = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${openaiApiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: "text-embedding-3-small", // 1536 dimensions, cost-effective
      input: text,
      encoding_format: "float" // For pgvector compatibility
    })
  });
  
  const data = await response.json();
  return data.data[0].embedding;
};
```

### 2.3 Vector Storage in PostgreSQL

**pgvector Integration:**
```sql
-- Store embedding in prescriptions table
UPDATE prescriptions 
SET embedding = $1::vector(1536),
    extracted_text = $2,
    processing_status = 'completed'
WHERE id = $3;

-- Create efficient index for similarity search
CREATE INDEX IF NOT EXISTS prescriptions_embedding_idx 
ON prescriptions USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);
```

---

## Phase 3: Intelligent Chat System

### 3.1 Context-Aware Query Processing

**Chat System Architecture:**
1. **User Query** ‚Üí Natural language question
2. **Context Retrieval** ‚Üí Find relevant prescriptions using vector search
3. **Context Assembly** ‚Üí Build comprehensive medical context
4. **AI Response** ‚Üí Generate informed, safe medical guidance
5. **Response Storage** ‚Üí Save conversation for continuity

### 3.2 Vector Similarity Search

**Smart Context Retrieval:**
```sql
-- Advanced similarity search function
CREATE OR REPLACE FUNCTION get_prescription_context(
  user_id uuid,
  query_text text,
  similarity_threshold float DEFAULT 0.75,
  max_results int DEFAULT 5
)
RETURNS TABLE(
  prescription_id uuid,
  doctor_name text,
  diagnosis text,
  medicines jsonb,
  consultation_date date,
  similarity_score float,
  context_relevance text
) 
LANGUAGE plpgsql AS $$
DECLARE
  query_embedding vector(1536);
BEGIN
  -- Generate embedding for user query
  SELECT embedding INTO query_embedding 
  FROM generate_query_embedding(query_text);
  
  RETURN QUERY
  SELECT 
    p.id,
    p.doctor_name,
    p.diagnosis,
    p.medicines,
    p.consultation_date,
    1 - (p.embedding <=> query_embedding) as similarity,
    CASE 
      WHEN 1 - (p.embedding <=> query_embedding) > 0.9 THEN 'highly_relevant'
      WHEN 1 - (p.embedding <=> query_embedding) > 0.8 THEN 'relevant' 
      ELSE 'contextual'
    END as relevance
  FROM prescriptions p
  WHERE p.user_id = get_prescription_context.user_id
    AND p.processing_status = 'completed'
    AND p.embedding IS NOT NULL
    AND 1 - (p.embedding <=> query_embedding) > similarity_threshold
  ORDER BY p.embedding <=> query_embedding
  LIMIT max_results;
END;
$$;
```

### 3.3 Intelligent Response Generation

**Chat System Prompt:**
```typescript
const CHAT_SYSTEM_PROMPT = `
You are MedGenie AI, a knowledgeable medical assistant helping users understand their prescription data. 

CORE PRINCIPLES:
1. SAFETY FIRST - Never provide medical advice that could harm
2. ACCURACY - Base responses only on provided prescription data  
3. CLARITY - Explain medical terms in simple language
4. EMPATHY - Be supportive and understanding
5. BOUNDARIES - Always recommend consulting healthcare providers

CAPABILITIES:
‚úÖ Explain prescribed medications and their purposes
‚úÖ Clarify dosage instructions and timing
‚úÖ Identify potential drug interactions from user's prescription history
‚úÖ Explain medical conditions mentioned in prescriptions
‚úÖ Help track medication schedules and compliance
‚úÖ Compare prescriptions from different doctors
‚úÖ Provide general medication information
‚úÖ Suggest questions to ask doctors

STRICT LIMITATIONS:
‚ùå Never diagnose medical conditions
‚ùå Never recommend changing prescribed dosages
‚ùå Never suggest stopping medications
‚ùå Never provide emergency medical guidance
‚ùå Never replace professional medical consultation
‚ùå Never speculate about conditions not in prescriptions

RESPONSE GUIDELINES:
1. Always reference specific prescription data when answering
2. Use clear, non-technical language
3. Include relevant context from user's prescription history
4. Highlight important safety information
5. Suggest follow-up questions for doctors when appropriate
6. Provide medication reminders and tips when helpful

EMERGENCY SITUATIONS:
If user mentions symptoms requiring immediate attention, respond:
"This sounds like it may need immediate medical attention. Please contact your doctor, call emergency services, or visit the nearest emergency room right away."

INTERACTION STYLE:
- Friendly but professional
- Supportive and reassuring
- Clear and educational  
- Proactive in identifying concerns
- Encouraging of doctor-patient communication
`;
```

### 3.4 Advanced Context Assembly

**Smart Context Building:**
```typescript
const buildChatContext = async (
  userId: string, 
  userQuery: string,
  prescriptionId?: string
): Promise<string> => {
  
  // Get relevant prescriptions via vector search
  const relevantPrescriptions = await supabase.rpc('get_prescription_context', {
    user_id: userId,
    query_text: userQuery,
    similarity_threshold: 0.7,
    max_results: 3
  });
  
  // Build comprehensive context
  let context = '';
  
  // Current prescription (if specified)
  if (prescriptionId) {
    const currentPrescription = await getCurrentPrescription(prescriptionId);
    context += `
CURRENT PRESCRIPTION:
Doctor: ${currentPrescription.doctor_name}
Date: ${currentPrescription.consultation_date}
Diagnosis: ${currentPrescription.diagnosis}
Medicines: ${formatMedicines(currentPrescription.medicines)}
    `;
  }
  
  // Related prescription history
  if (relevantPrescriptions.length > 0) {
    context += `\nRELATED PRESCRIPTION HISTORY:\n`;
    relevantPrescriptions.forEach((prescription, index) => {
      context += `
${index + 1}. Dr. ${prescription.doctor_name} (${prescription.consultation_date})
   Diagnosis: ${prescription.diagnosis}
   Key Medicines: ${prescription.medicines.map(m => m.name).slice(0, 3).join(', ')}
   Relevance: ${prescription.context_relevance}
      `;
    });
  }
  
  // Medicine interaction analysis
  const allMedicines = getAllUserMedicines(userId);
  const interactions = await checkDrugInteractions(allMedicines);
  if (interactions.length > 0) {
    context += `\nPOTENTIAL DRUG INTERACTIONS:\n${interactions.join('\n')}`;
  }
  
  // User's medication patterns
  const patterns = await analyzeMedicationPatterns(userId);
  context += `\nMEDICATION PATTERNS:\n${patterns}`;
  
  return context;
};
```

### 3.5 Response Enhancement Features

**Smart Response Features:**

1. **Drug Interaction Detection:**
```typescript
const checkDrugInteractions = (medicines: Medicine[]): string[] => {
  const interactions: string[] = [];
  const commonInteractions = {
    'warfarin': ['aspirin', 'ibuprofen'],
    'metformin': ['alcohol'],
    'lisinopril': ['potassium supplements']
  };
  
  medicines.forEach(med1 => {
    medicines.forEach(med2 => {
      if (med1.name !== med2.name) {
        const interaction = findInteraction(med1.name, med2.name);
        if (interaction) {
          interactions.push(`‚ö†Ô∏è ${med1.name} + ${med2.name}: ${interaction}`);
        }
      }
    });
  });
  
  return interactions;
};
```

2. **Medication Scheduling:**
```typescript
const generateMedicationSchedule = (medicines: Medicine[]): Schedule => {
  return medicines.map(med => ({
    medicine: med.name,
    times: parseDosageFrequency(med.frequency),
    withFood: med.instructions.includes('food'),
    duration: med.duration,
    reminders: generateReminders(med.frequency)
  }));
};
```

3. **Educational Content:**
```typescript
const enhanceWithEducation = (response: string, medicines: Medicine[]): string => {
  let enhanced = response;
  
  medicines.forEach(med => {
    const education = getMedicineEducation(med.name);
    if (education) {
      enhanced += `\n\nüìö About ${med.name}: ${education.purpose}`;
    }
  });
  
  return enhanced;
};
```

---

## Phase 4: Conversation Memory & Learning

### 4.1 Chat History Integration

**Conversation Context:**
```typescript
const getChatHistory = async (prescriptionId: string, limit: number = 10) => {
  const { data: chatHistory } = await supabase
    .from('chat_messages')
    .select('message, response, created_at')
    .eq('prescription_id', prescriptionId)
    .order('created_at', { ascending: false })
    .limit(limit);
    
  return chatHistory?.reverse() || [];
};

const buildConversationContext = (chatHistory: ChatMessage[]): string => {
  if (chatHistory.length === 0) return '';
  
  return `
RECENT CONVERSATION:
${chatHistory.map(chat => 
  `User: ${chat.message}\nMedGenie: ${chat.response}`
).join('\n\n')}
  `;
};
```

### 4.2 Personalized Responses

**User Pattern Analysis:**
```typescript
const analyzeUserConcerns = async (userId: string): Promise<UserProfile> => {
  const { data: messages } = await supabase
    .from('chat_messages')
    .select('message')
    .eq('user_id', userId);
    
  const concerns = extractConcerns(messages);
  const frequency = analyzeQuestionPatterns(messages);
  
  return {
    primaryConcerns: concerns,
    questionTypes: frequency,
    communicationStyle: determineStyle(messages),
    medicalLiteracy: assessLiteracy(messages)
  };
};
```

---

## Error Handling & Quality Assurance

### Response Validation
```typescript
const validateAIResponse = (response: string): ValidationResult => {
  const flags = [
    checkForMedicalAdvice(response),
    checkForDosageChanges(response),
    checkForDiagnosticClaims(response),
    checkForEmergencyContent(response)
  ];
  
  return {
    isSafe: flags.every(flag => !flag.detected),
    warnings: flags.filter(flag => flag.detected),
    confidence: calculateResponseConfidence(response)
  };
};
```

### Fallback Mechanisms
```typescript
const handleAIFailure = (error: Error): ChatResponse => {
  logger.error('AI processing failed', error);
  
  return {
    response: "I'm having trouble processing your question right now. Please try again, or contact your healthcare provider for immediate assistance.",
    fallback: true,
    suggestedActions: [
      'Retry your question',
      'Contact your doctor',
      'Check prescription label directly'
    ]
  };
};
```

---

## Performance Optimizations

### 1. Embedding Caching
```typescript
const embeddingCache = new Map<string, number[]>();

const getCachedEmbedding = async (text: string): Promise<number[]> => {
  const hash = createHash(text);
  
  if (embeddingCache.has(hash)) {
    return embeddingCache.get(hash)!;
  }
  
  const embedding = await generateEmbedding(text);
  embeddingCache.set(hash, embedding);
  return embedding;
};
```

### 2. Response Streaming
```typescript
const streamChatResponse = async (context: string, query: string) => {
  const stream = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      { role: 'system', content: CHAT_SYSTEM_PROMPT },
      { role: 'user', content: `${context}\n\nUser Question: ${query}` }
    ],
    stream: true,
    max_tokens: 800,
    temperature: 0.3
  });
  
  return stream;
};
```

### 3. Batch Processing
```typescript
const processPrescriptionsBatch = async (prescriptions: File[]) => {
  const batches = chunkArray(prescriptions, 5);
  
  for (const batch of batches) {
    await Promise.all(
      batch.map(file => processPrescription(file))
    );
    
    // Rate limiting pause
    await sleep(1000);
  }
};
```

---

## Security & Privacy

### Data Protection
- All medical data encrypted at rest and in transit
- PHI handling compliant with HIPAA guidelines  
- Vector embeddings don't contain identifiable information
- Regular security audits of AI processing pipeline

### AI Safety Measures
- Response validation prevents harmful medical advice
- Conversation logging for quality assurance
- Fallback mechanisms for AI failures
- Human oversight integration points

This comprehensive AI workflow ensures MedGenie 2.0 provides accurate, safe, and helpful prescription management while maintaining the highest standards of medical data privacy and security.